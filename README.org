* Lenguajes de Programación Grupo 7084
Correos:
+ Profesor: L. en C.C. Fernando Abigail Galicia Mendoza | fernandogamen@ciencias.unam.mx
+ Ayudante: Alexis Rivas León | alex-rivasl@ciencias.unam.mx
+ Laboratorio: Emiliano Galeana Araujo | galeanaara@ciencias.unam.mx

Curso:
+ Classroom
+ [[https://t.me/joinchat/L0xngv-r02EwYzFh][telegram]]
+ [[https://drive.google.com/drive/u/0/folders/136bZP00WtqWWFJAkZDo7mS-OsAx_B_7zWCc1iZVEvYp3vDKIpuMTPoECgpc_w9RvkkSYJrc8][drive]]
+ [[https://meet.google.com/vhh-hvip-aci?authuser=0&hs=179][Clases]]
+ LP20221-ASUNTO

* N-clase (Práctica 3)

** Cálculo lambda
*** Sintaxis

Empezamos con lo  básico, lo mismo de  siempre, necesiamos =Data.List=
para =`union`=  y =Data.Char= para  poder hacer la  alpha equivalencia
(Cambiar de caracteres a números).

=Test.HUnit= es para lo mismo de siempre.

#+BEGIN_SRC haskell
module PureLambda where

import Data.List
import Data.Char
import Test.HUnit
#+END_SRC

Nuestro =data= y nuevos =type='s.

#+BEGIN_SRC haskell
-- | Type that represents the set of possible variable names.
type Name = String

-- | Type that represents the substitution.
type Subst = (Name,Lambda)

data Lambda = V Name                         -- ^ Constructor for the variables.
            | App Lambda Lambda              -- ^ Constructor for the applications.
            | L Name Lambda                  -- ^ Constructor for the abstractions.
            | Let Name Lambda Lambda         -- ^ Constructor for the let.
            | Fun Name Lambda                -- ^ (NEW) Syntax sugar for lambda
            | LetFun Name Name Lambda Lambda -- ^ Constructor for the name functions.
#+END_SRC

Instancia  de =Show=  para  =Lambda=.  Tenemos  azúcar sintáctica,  la
pueden encontrar en  la nota 6, sección 4. Para  eso usamos la función
=desugar=.  Esto  quiere decir  que de  todos los  constructores, solo
vamos  a  trabajar   con  tres,  los  demás   de  pueden  /desugarizar
(desazucarizar (?))/.

#+BEGIN_SRC haskell
-- Instance for a pretty/decent print.
instance Show Lambda where
  show l = case l of
    V x -> x
    App t s -> "("++show t++" <+> "++show s++")"
    L x t -> "(lam ("++x++") -> "++show t++")"
    Fun x t -> "(fun ("++x++") => "++show t++")"
    Let x t1 t2 -> "let \n"++x++":="++show t1++"\nin\n"++show t2++"\nend"
    LetFun f x t1 t2 -> "let fun \n"++f++" "++x++" "++" => "++show t1++"\nin\n"++show t2++"\nend"
#+END_SRC

*** sustitution
Para hacer =substitution= necesitamos =alpha=, y para este necesitamos
renombrar variables. Además, necesitamos =fv=.

#+BEGIN_SRC haskell
-- | The  substitution function  applies the  substitution given  as a
-- parameter to a lambda term.
substitution :: Lambda -> Subst -> Lambda
#+END_SRC

...

Ya  que podemos  renombrar variables  y sacar  la alpha  equivalencia,
podemos hacer una sustitución.

Una sutitución  en la  mayoría de  los casos es  igual que  siempre, o
propagamos,  o tenemos  que  ver que  si es  una  variable, el  nombre
(=Name=) sea  igual al de la  sustitición para aplicarla, si  no es el
caso, no hacemos nada.

La parte  interesante es  para las  Lambdas, necesitamos  calcular las
variables libres.

Algoritmo

1. Si la variable  de la lambda NO está en la  lista (conjunto) de las
   variables libres  del cuerpo de la  sustitución y no es  igual a la
   variable de la sustitución, entonces podemos aplicar la sustitución
   al cuerpo de la lambda.
2. Si  no es  el  caso,  necesitamos  aplicar  la sustitución  a  una
   alpha-equivalencia de la lambda.

(alpha (L v cuerpo)) (s,t)

*** Alpha equivalencia
Para =alpha= necesitamos la función =newId= que básicamente lo que nos
da es un nuevo nombre.

#+BEGIN_SRC haskell
-- | The  alpha function generates  the alpha-equivalence of  a lambda
-- term.
alpha :: Lambda -> Lambda
#+END_SRC

...

Ya que  podemos renombrar variables,  un alpha equivalencia  se aplica
únicamente  a las  lambdas,  todo lo  demás  o se  queda  igual, o  se
propaga, ¿Cómo se hace con las lambdas?

**** Algoritmo
1. Crear una nueva variable
2. Tenemos =Lambda variable cuerpo=,  cambiar la variable por la nueva
   variable.
3. Hacer recursión sobre el cuerpo*
4. Hacer uns sustitución de la antigua variable por la nueva variable.

L v cuerpo

L v1 (cuerpo (v,v1))

*** newId
Función que crea una nueva variable:n
1. Si al final de la variable no hay un número, entonces la función le
   agrega el /0/ al final del nombre a la variable
2. Si al final hay un número, entonces la función cambia el número por
   su sucesor.

"hola"   -> ("hola", "") -> "hola0"
"hola0"  -> ("hola", "0") -> "hola1"
"hola19" -> "hola20"

"adios123hola" -> ("adios123hola", "0") -> "adios123hola0"

#+BEGIN_SRC haskell
{-|
The newId function creates a new variable with the following conditions:
1. If at the end of the variable is not a number then the function 
add the number 0 at the end of the variable.
2. If at the end of the variable is a number then the function
replace the original number with its sucessor.
-} 
newId :: Name -> Name
newId x
#+END_SRC

Algoritmo (Mi implementación)

1. Partir la cadena  =x= que recibimos en dos =(str, int)= que son la
   parte alfanumérica y numérica respectivamente.
2. Verificar si la parte numérica existe o no.
   1. Si no existe, le agregamos /0/.
   2. Si existe, la cambiamos a  entero, le aplicamos el sucesor, y la
      "pegamos".

:my-imp:
#+BEGIN_SRC haskell
newId :: Name -> Name
newId x
  | int == "" = x ++ "0"
  | otherwise = str ++ (show $ read int + 1)
  where
    (str, int) = splitName (reverse x) ("","")
#+END_SRC
:end:

"hola123" -> splitName ("321aloh") ("", "")

*** splitName

Función auxiliar que parte la cadena (paso 1 del algoritmo anterior).

Podemos usar de =Data.Char=, y =Data.List= las funciones:

- =isDigit=: Nos dice si un caracter es o no un dígito.
- =reverse=: Regresa la reversa de una lista (=String=).

#+Begin_SRC haskell
{-|
The splitName function tries to split strings of the form "vn" returning
the pair (v,n) where "v" could be any string but "n" is a string with only numbers.
If the string doesn't end with a number then "n" will be equal to the empty string.
-}
splitName :: Name -> (Name,Name) -> (Name,Name)
#+END_SRC

Algoritmo (Mi implementación)

Necesitamos un acumulador (Por la firma  de la función); La firma dice
que recibe un =Name= que es solo otro nombre para =String= y una tupla
de =Name='s  (=(Name, Name)=),  al final regresa  una tupla  del mismo
tipo.

La idea  entonces es  que la  tupla que recibe  la función  sirva como
acumulador, guardando en  el primer argumento la parte de  cadena y en
el segundo la parte de entero.

Entonces, podemos empezar por atrás...

1. Sacar la reversa de la cadena  (A la que le queremos sacar un nuevo
   nombre)
2. Iniciar nuestro  acumulador en lo más básico,  ambos argumentos son
   =String=.
3. Verificar si la cadenena (Nombre de variable) es vacía.
   1. Si es vacía, terminamos y regresamos el acumulador.
   2. E.o.c, verificamos si el primer argumento es o no un dígito.
      1. Si  es un  dígito,  lo  agregamos  al acumulador  y  hacemos
        recursión con el resto de la cadena.
      2. Si  no es un dígito,  terminamos (Solo hay que  tener cuidado
         con el orden de la cadena).

"hola123" ("", "") -> -- "321aloh"
"hola12"  ("", "3") ->
"hola1"   ("", "23") ->
"hola"    ("", "123") ->
""        ("hola", "123") ->

:my-imp:
#+BEGIN_SRC haskell
splitName [] (str, int) = (str, int)
splitName l@(x:xs) (str, int)
  | isDigit x = splitName xs (str, [x]++int)
  | otherwise = (reverse l, int)
#+END_SRC
:end:

*** fv

Es lo mismo  de siempre, si existe  la variable, se agrega,  si no hay
variable se propaga, si la variable  está ligada, se quita de donde se
esté ligando.

#+BEGIN_SRC haskell
-- | The fv function takes an abstraction and returns their free variables.
fv :: Lambda -> [Name]
#+END_SRC
*** TODO desugar
=Let=,  =LetFun=,  =Fun=   (En  la  nota  6)  las   podemos  ver  como
   aplicaciones en términos de las otras 3.

[[https://drive.google.com/file/d/1z9VkCI0yqRMiWxL4kAmhGtMvppmdIQky/view?usp=sharing2][nota 6]] Sección 4

#+BEGIN_SRC haskell
-- | The desugar function unfold the definitions of let and letfun
desugar :: Lambda -> Lambda
desugar (Fun f e) = L f e
desugar (LetFun f x e1 e2) = error "D:"
desugar (Let x e1 e2) = App (L x e2) (e1)
desugar e = e
#+END_SRC

*** beta
(nota  5, Sección  2) pero  tengan cuidado  con la  caza de  patrones,
necesitan un patrón repetido (Usar =normal=).

#+BEGIN_SRC haskell
-- | The beta function is an implementation of the beta reduction.
beta :: Lambda -> Lambda
beta (App (L x t) r) = substitution (t) (x,r)
beta (App ... ...) = error "D:"
beta (L y t) = L y (beta t)
#+END_SRC

*hint: V x no tiene betareducción.*
*hint: App t1 t2 tiene dos posibles betareducciones.*
*** normal
normal: (nota 5, sección  2) pero en general V está,  L está syss está
el cuerpo, App tarea

#+BEGIN_SRC haskell
-- | The normal function is the predicate that is True iff a lambda term is in normal form.
normal :: Lambda -> Bool
normal (V x) = True
normal (L x t) = normal t
normal (App t1 t2) = error "D:"
#+END_SRC

(t1)(t2)
si t1 := (\x.e1)
(\x.e1)(e2)

(\x.xx)(e2) => (e2)(e2)

*hint: jugar con los posibles patrones de t1.*
*** betas
necesitamos a normal y a =beta=.

El algoritmo  es: si la  expresión está  en forma normal,  entonces la
regresamos, y si  no está, entonces aplicamos una  reducción hasta que
lo esté.

Como nota, hay que /aplicarles insulina a las expresiones/.

*hint: antes de aplicar el algoritmo, aplicar =desugar=*

#+BEGIN_SRC haskell
{-| 
The betas function is a implementation of the reflexive-transitive closure of the beta
reduction. Before the application of the beta reduction, this function test if the lambda
term is in normal form.
2-}
betas :: Lambda -> Lambda
betas l = error "D:"
#+END_SRC

while (!isNormal(l)) {
    betreduce(l)
}
** Mini Haskell
*** Sintaxis

#+BEGIN_SRC haskell
import Data.List
import Data.Char
#+END_SRC

types que necesitamos para el desarrollo

#+BEGIN_SRC haskell
-- | Type that represents the set of possible variable names.
type Name = String

-- | A 'Decl' is a pair that represents the declaration of a variable x
-- has a type T.
type Decl = (Name,Type)
  
-- | A 'TypeCtx' is the list of the declarations of variables.
type TypeCtx = [Decl]

-- | Type that represents the substitution.
type Subst = (Name,MiniHs)
#+END_SRC

Necesitamos también constructores para "tipos".

#+BEGIN_SRC haskell
-- | A 'Type' is a implementation of the abstract syntax of types.
data Type = NAT | BOOL | T Name | Type :-> Type deriving(Show,Eq)
#+END_SRC

**** Tipos

Tenemos  constructores  para todos  los  operadores  que hemos  estado
viendo, estos son tipados.

#+BEGIN_SRC haskell
-- | A 'MiniHs' is a implementation of the abstract syntax of typed Mini Haskell programs.
data MiniHs = V Name                   -- ^ Constructor for the typed variables.
            | N Int                    -- ^ Constructor for the typed numbers.
            | B Bool                   -- ^ Constructor for the typed booleans.
            | Suc MiniHs               -- ^ Constructor for the typed successor operator.
            | Pred MiniHs              -- ^ Constructor for the typed predecessor operator.
            | Plus MiniHs MiniHs       -- ^ Constructor for the typed plus operator.
            | Prod MiniHs MiniHs       -- ^ Constructor for the typed product operator.
            | Neg MiniHs               -- ^ Constructor for the typed negation operator.
            | Conj MiniHs MiniHs       -- ^ Constructor for the typed conjunction operator.
            | Disy MiniHs MiniHs       -- ^ Constructor for the typed disjunction operator.
            | Gt MiniHs MiniHs         -- ^ Constructor for the typed greater than operator.
            | Lt MiniHs MiniHs         -- ^ Constructor for the typed lower than operator.
            | Equi MiniHs MiniHs       -- ^ Constructor for the typed equality operator.
            | Ift MiniHs MiniHs MiniHs -- ^ Constructor for the typed if-else conditional.
            | L Name Type MiniHs       -- ^ Constructor for the typed abstraction.
            | Fix Name Type MiniHs     -- ^ Constructor for the typed fix operator.
            | App MiniHs MiniHs        -- ^ Constructor for the typed application.
#+END_SRC

**** Sin tipos

También  tenemos constructores  para  todos los  operadores que  hemos
estado viendo, que son no tipados.

#+BEGIN_SRC haskell
-- | A 'MiniHsU' is a implementation of the abstract syntax of untyped Mini Haskell programs.
data MiniHsU = VU Name                      -- ^ Constructor for the untyped variables.
             | NU Int                       -- ^ Constructor for untyped numbers.
             | BU Bool                      -- ^ Constructor for untyped booleans.
             | SucU MiniHsU                 -- ^ Constructor for untyped successor operator.
             | PredU MiniHsU                -- ^ Constructor for untyped predecessor operator.
             | PlusU MiniHsU MiniHsU        -- ^ Constructor for untyped plus operator.
             | ProdU MiniHsU MiniHsU        -- ^ Constructor for untyped product operator.
             | NegU MiniHsU                 -- ^ Constructor for untyped negation operator.
             | ConjU MiniHsU MiniHsU        -- ^ Constructor for untyped conjunction operator.
             | DisyU MiniHsU MiniHsU        -- ^ Constructor for untyped disjunction operator.
             | GtU MiniHsU MiniHsU          -- ^ Constructor for untyped greater than operator.
             | LtU MiniHsU MiniHsU          -- ^ Constructor for untyped lower than operator.
             | EquiU MiniHsU MiniHsU        -- ^ Constructor for untyped equality operator.
             | IftU MiniHsU MiniHsU MiniHsU -- ^ Constructor for untyped if-else operator.
             | LU Name MiniHsU              -- ^ Constructor for untyped abstraction.
             | FixU Name MiniHsU            -- ^ Constructor for untyped fix operator.
             | AppU MiniHsU MiniHsU         -- ^ Constructor for untyped application operator.
#+END_SRC

*** fv

Toma un programa de Mini Haskell (tipado) y regresa las variables libres.

#+BEGIN_SRC haskell
-- | The 'fv' function takes a typed Mini Haskell program and returns their free variables.
fv :: MiniHs -> [Name]
fv (V n)       = [n]
fv (Suc mh)    = fv mh
fv (Ift b t e) = fv b `union` fv t `union` fv e
fv (Fix n _ e) = fv e \\ [n]
#+END_SRC

(\x.xx)

*** newId

Función que crea una nueva variable:n
1. Si al final de la variable no hay un número, entonces la función le
   agrega el /0/ al final del nombre a la variable
2. Si al final hay un número, entonces la función cambia el número por
   su sucesor.

"hola"   -> ("hola", "") -> "hola0"
"hola0"  -> ("hola", "0") -> "hola1"
"hola19" -> "hola20"

"adios123hola" -> ("adios123hola", "0") -> "adios123hola0"

#+BEGIN_SRC haskell
{-|
The newId function creates a new variable with the following conditions:
1. If at the end of the variable is not a number then the function 
add the number 0 at the end of the variable.
2. If at the end of the variable is a number then the function
replace the original number with its sucessor.
-} 
newId :: Name -> Name
newId x
#+END_SRC

*** splitName

Función auxiliar que parte la cadena (paso 1 del algoritmo anterior).

Podemos usar de =Data.Char=, y =Data.List= las funciones:

- =isDigit=: Nos dice si un caracter es o no un dígito.
- =reverse=: Regresa la reversa de una lista (=String=).

#+Begin_SRC haskell
{-|
The splitName function tries to split strings of the form "vn" returning
the pair (v,n) where "v" could be any string but "n" is a string with only numbers.
If the string doesn't end with a number then "n" will be equal to the empty string.
-}
splitName :: Name -> (Name,Name) -> (Name,Name)
#+END_SRC

*** alpha

Genera una alpha-equivalencia para un programa de Mini Haskell tipado.

#+BEGIN_SRC haskell
-- | The 'alpha' function generates the alpha-equivalence of a typed Mini Haskell program.
alpha :: MiniHs -> MiniHs
alpha (V n)       = (V n)
alpha (Suc mh)    = Suc (alpha mh)
alpha (Ift b t e) = Ift (alpha b) (alpha t) (alpha e)
alpha (Fix n t e) = Fix n1 t (alpha (substitution e (n1, n))) where
  n1 = newId n
#+END_SRC

*** substitution

Función que aplica una sustitución a un programa de Mini Haskell tipado.

#+BEGIN_SRC haskell
-- | The 'substitution' function applies the substitution given as 
-- a parameter to a typed Mini Haskell program.
substitution :: MiniHs -> Subst -> MiniHs
substitution (V n) (y, t)        = if n == y then t else (V n)
substitution (Suc mh)    s       = Suc (substitution mh s)
substitution (Ift b t e) s       = Ift (substitution b s) (substitution t s) (substitution e s)
substitution f@(Fix n t e) s@(y,t') = case not (n `elem` [y] `union` fv t) of
  True  -> Fix n t (substitution e s)
  False -> let f' = alpha f in substitution f' s
#+END_SRC

fix "x" T (V "x") ("x", 1)

fv 1 = [] ++ ["x"] -> "x" `elem` ["x"] -> T -> F

*** TODO ejemplos de sustitución en Fix
